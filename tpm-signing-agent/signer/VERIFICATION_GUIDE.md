# Signature Verification Guide

This guide explains how to verify signatures generated by the TPM signing server and understand the v value.

## Understanding Ethereum Signatures

Ethereum signatures consist of three components:

1. **r** (32 bytes): First part of the ECDSA signature
2. **s** (32 bytes): Second part of the ECDSA signature  
3. **v** (1 byte): Recovery ID that allows public key recovery

### Signature Formats

- **64-byte signature**: Contains only `r + s` components
- **65-byte signature**: Contains `r + s + v` components

## Server Endpoints

### 1. Sign Transaction (`POST /sign`)

**Request:**
```json
{
  "txHashHex": "0xce092d40e81b6994594db49f209ac5b980049c24a4bef5f775318d4e12497164"
}
```

**Response:**
```json
{
  "signature": "abc123...",      // 64-byte hex (r+s)
  "signatureWithV": "abc123...", // 65-byte hex (r+s+v)
  "v": 0,                       // Recovery ID (0 or 1)
  "r": "abc123...",             // 32-byte r component
  "s": "def456..."              // 32-byte s component
}
```

### 2. Verify Signature (`POST /verify`)

**Request (65-byte signature):**
```json
{
  "txHashHex": "0xce092d40e81b6994594db49f209ac5b980049c24a4bef5f775318d4e12497164",
  "signature": "abc123...def"   // 65-byte signature (includes v)
}
```

**Request (64-byte signature with explicit v):**
```json
{
  "txHashHex": "0xce092d40e81b6994594db49f209ac5b980049c24a4bef5f775318d4e12497164",
  "signature": "abc123...",     // 64-byte signature (r+s only)
  "v": 0                       // Explicit v value
}
```

**Request (64-byte signature with auto-detection):**
```json
{
  "txHashHex": "0xce092d40e81b6994594db49f209ac5b980049c24a4bef5f775318d4e12497164",
  "signature": "abc123..."      // 64-byte signature, server tries both v values
}
```

**Response:**
```json
{
  "valid": true,
  "recoveredAddress": "0x1234...5678",
  "expectedAddress": "0x1234...5678",
  "message": "Signature is valid!"
}
```

## How Signature Verification Works

1. **Public Key Recovery**: Using the signature (r, s, v) and the original message hash, the verifier can recover the public key that created the signature.

2. **Address Derivation**: The recovered public key is used to derive an Ethereum address.

3. **Address Comparison**: The recovered address is compared with the expected address (from the TPM).

4. **Validation**: If the addresses match, the signature is valid.

## The V Value Explained

The **v value** (recovery ID) is crucial because:

- ECDSA signatures alone don't uniquely identify the signer
- For any valid signature, there are typically 2-4 possible public keys that could have created it
- The v value tells us which of these possible public keys is the correct one
- Without the correct v value, you cannot reliably recover the signer's address

### V Value Ranges

- **Modern format**: v = 0 or 1
- **Legacy format**: v = 27 or 28 (adds 27 to modern format)
- **EIP-155 format**: v = chain_id * 2 + 35 + recovery_id (for replay protection)

## Manual Verification Steps

### Step 1: Get the signature components
```bash
# Sign a transaction
curl -X POST http://localhost:8080/sign \
  -H "Content-Type: application/json" \
  -d '{"txHashHex": "0xce092d40e81b6994594db49f209ac5b980049c24a4bef5f775318d4e12497164"}'
```

### Step 2: Verify the signature
```bash
# Verify with 65-byte signature
curl -X POST http://localhost:8080/verify \
  -H "Content-Type: application/json" \
  -d '{"txHashHex": "0xce092d40e81b6994594db49f209ac5b980049c24a4bef5f775318d4e12497164", "signature": "SIGNATURE_FROM_STEP_1"}'
```

### Step 3: Cross-verify with external tools

You can also verify signatures using:

1. **ethers.js**:
```javascript
const ethers = require('ethers');
const recoveredAddress = ethers.utils.verifyMessage(messageHash, signature);
```

2. **viem**:
```javascript
import { recoverAddress } from 'viem';
const recoveredAddress = recoverAddress({ hash, signature });
```

3. **Safe SDK**: The signatures are directly compatible with Safe SDK's signature format.

## Common Issues and Solutions

### Issue 1: "Invalid recovery ID"
- **Cause**: Wrong v value or signature corruption
- **Solution**: Use the `/verify` endpoint to auto-detect the correct v value

### Issue 2: "Signature recovers to different address"
- **Cause**: Signature was created by a different key or is corrupted
- **Solution**: Verify the TPM handle and re-sign

### Issue 3: "Signature malleability"
- **Cause**: High s values in signature
- **Solution**: The server automatically normalizes signatures (s â‰¤ N/2)

## Integration Examples

### For Safe SDK
```javascript
// Use the 64-byte signature directly
const signature = "0x" + signResponse.signature;
// Safe SDK will handle v value internally
```

### For Custom dApps
```javascript
// Use the 65-byte signature for manual verification
const signature = "0x" + signResponse.signatureWithV;
const recoveredAddress = ethers.utils.recoverAddress(txHash, signature);
```

### For Metamask-style signing
```javascript
// Convert to Metamask format if needed
const v = signResponse.v + 27; // Convert to legacy format
const signature = signResponse.r + signResponse.s + v.toString(16).padStart(2, '0');
```

## Testing Your Implementation

Run the comprehensive test script:
```bash
./test_server.sh
```

This will test:
1. Address retrieval
2. Transaction signing
3. Signature verification (multiple formats)
4. Invalid signature detection

The test script demonstrates all verification methods and shows you exactly how to validate signatures in your own applications.
